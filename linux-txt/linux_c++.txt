1. 析构与线程安全
    析构函数调用，在对象销毁之后

2. composite（组合）在多线程不会有问题
    组合 (Composition) 指在一个类中另一类的对象作为数据成员
    
    对象x生命周期由唯一拥有者owner控制，当owner析构，会把x析构

3. 引用计数型智能指针shared_ptr/weak_ptr

4. C++内存问题：
    缓冲区溢出：用std::vector<char>/std::string或者自己编写的buffer class管理
                缓冲区，自动记住长度，通过成员函数修改，不使用裸指针

    空悬指针/野指针：用智能指针

    重复释放：用scoped_ptr，在析构对象时释放一次

    内存泄漏：用scoped_ptr,对象析构时自动释放内存

5. share_ptr<Foo> *pFoo = new shared_ptr<Foo>(new Foo); //wrong
    值语义，要么时栈上对象，其他对象直接数据成员，或标准容器元素：
        这样值语义的一个巨大好处是生命期管理很简单

6. RAII 
    RAII正是利用这种机制，利用类来管理资源，将资源与类对象的生命周期绑定，即在
    对象创建时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有
    效，最后在对象析构时，释放所获取的资源。

    对于系统中的资源不具有自动释放的功能， 而C++中的类具有自动调用析构函数的功能，
    因此我们可以将资源用类进行封装起来，对资源的操作都封装在类的内部，在析构函
    数中进行资源的释放。

    class ArrayOperation 
    { 
    public : 
    ArrayOperation() 
    { 
        m_Array = new int [10]; 
    } 

    void InitArray() 
    { 
        for (int i = 0; i < 10; ++i) 
        { 
            *(m_Array + i) = i; 
        } 
    } 

    void ShowArray() 
    { 
        for (int i = 0; i <10; ++i) 
        { 
            cout<<m_Array[i]<<endl; 
        } 
    } 

    ~ArrayOperation() 
    { 
        cout<< "~ArrayOperation is called" <<endl; 
        if (m_Array != NULL ) 
        { 
            delete[] m_Array;  
            m_Array = NULL ; 
        } 
    } 

    private : 
        int *m_Array; 
    }; 

    int main() 
    { 
        ArrayOperation arrayOp;    //创建一个资源对象
        arrayOp.InitArray();       //获取资源
        arrayOp.ShowArray();       //对资源进行操控，完成后自动释放资源
        return 0;
    }

    在资源管理方面，智能指针(std::shared_ptr和std::unique_ptr)是RAII最具代表性
    的实现，使用了智能指针，可以实现自动的内存管理，再也不用担心忘记delete造成内
    存泄漏了。

    在状态管理方面，线程同步中使用std::unique_lock或std::lock_guard对互斥量
    std::mutex进行状态管理也是RAII的典型实现，通过这种方式，我们再也不用担心互
    斥量之间的代码出现异常而造成线程死锁。