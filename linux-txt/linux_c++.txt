1. 析构与线程安全
    析构函数调用，在对象销毁之后

2. composite（组合）在多线程不会有问题
    组合 (Composition) 指在一个类中另一类的对象作为数据成员
    
    对象x生命周期由唯一拥有者owner控制，当owner析构，会把x析构

3. 引用计数型智能指针shared_ptr/weak_ptr

4. C++内存问题：
    缓冲区溢出：用std::vector<char>/std::string或者自己编写的buffer class管理
                缓冲区，自动记住长度，通过成员函数修改，不使用裸指针

    空悬指针/野指针：用智能指针

    重复释放：用scoped_ptr，在析构对象时释放一次

    内存泄漏：用scoped_ptr,对象析构时自动释放内存

5. share_ptr<Foo> *pFoo = new shared_ptr<Foo>(new Foo); //wrong
    值语义，要么时栈上对象，其他对象直接数据成员，或标准容器元素：
        这样值语义的一个巨大好处是生命期管理很简单

6. 服务器基本框架
    io处理单元--逻辑单元--网络存储单元
    （各单元通过请求队列进行通信)

    IO处理单元：等待并接受客户的连接，接受客户数据，将服务器响应数据返回给客户
                端。
    
    逻辑单元：线程或进程，分析处理数据，传递结果给io处理单元，服务器有多个逻辑
                单元，实现对多个客户任务进行处理。
    
    io处理单元接收到客户端请求，通过请求队列通知逻辑单元，通常实现为池的一部分

7. IO模型
    （1）阻塞IO
    （2）IO复用：可监听多个IO事件
    （3）SIGIO信号：信号触发读写就绪，用户程序执行读写操作，没有阻塞
    （4）异步IO：内核执行读写操作，触发读写完成事件，没有阻塞

    服务器处理的主要三类事件：IO事件、信号、定时事件。

8. 事件处理模式
    reactor：同步IO实现reactor模式
    proactor：异步IO

9. reactor：
    主线程（IO处理单元）只监听文件描述符是否有事件，有事件则通知工作线程（逻辑
    处理单元），主线程不做实质性工作，读写数据、接收新连接都由工作线程完成。

    主线程等待socket有数据可读，将socket可读事件放入请求队列；某工作线程被唤醒
    从socket读数据、处理数据，往epoll_wait内核注册写就绪；主线程等待写就绪，将
    写事件放入请求队列，工作线程被唤醒，处理。

10. proactor：
    主线程（IO处理单元）和内核处理所有IO操作，工作线程负责业务逻辑。
    
    主线程调用aio_read函数向内核注册读完成事件，告诉内核用户读缓冲区位置，及
    读操作完成时如何通知应用程序；主线出处理其他逻辑；数据接收读入用户缓冲区
    后，内核向应用程序发送信号，通知数据可用；应用程序通过信号处理函数选择工
    线程处理客户请求，向内核注册写完成事件，告诉内核缓冲区位置，以及写操作信
    号通知应用程序；用户程序写入socket之后， 内核向应用程序发送信号，通知应
    用程序数据已发送完毕；应用程序根据预定信号处理函数，决定是否关闭socket
    等操作。

11. 半同步、半异步
    同步和异步区分在于，内核向应用程序通知是就绪事件还是完成事件，以及谁来
    进行读写

    并发模式中，同步是程序顺序执行，异步指程序执行由系统事件驱动（中断、信号）
    


